use std::sync::Arc;

use crate::{board::{game::{MoveController, get_theoretical_moves_bound, MoveLegalResponse}, Board, actions::{Move, TheoreticalMove, CounterUpdate, TurnUpdate}, BoardState}, bitboard::BitBoard, games::chess::pieces::CASTLING_MOVE};

use super::{ATTACKS_MODE, pieces::KING};

#[derive(Debug)]
pub struct ChessMoveController<const T: usize>;

impl<const T: usize> MoveController<T> for ChessMoveController<T> {
    fn transform_moves(&self, board: &mut Board<T>, mode: u16, _actions: Vec<Move>) -> Vec<Move> {
        let moves = board.generate_moves(mode);
        let mut legal_moves = Vec::with_capacity(moves.len());
        for action in moves {
            if self.is_legal(board, &action, true).is_legal {
                legal_moves.push(action);
            }
        }
        legal_moves
    }

    fn is_legal(&self, board: &mut Board<T>, action: &Move, unmake_move: bool) -> MoveLegalResponse<T> {
        match action {
            Move::Action(action) => {
                let to_board = BitBoard::from_lsb(action.to);
                let kings = board.state.pieces[KING];
                if (to_board & kings).is_set() {
                    return MoveLegalResponse {
                        made_move: None,
                        is_legal: false
                    };
                }

                let current_team = board.state.moving_team;

                let undo = board.make_move(&Move::Action(*action));
                let kings = board.state.pieces[KING];
                let king_board = board.state.teams[current_team as usize] & kings;
                let in_check = board.can_move(board.state.moving_team, king_board, ATTACKS_MODE);
                if unmake_move { 
                    board.undo_move(undo);
                    MoveLegalResponse {
                        made_move: None,
                        is_legal: !in_check
                    }
                } else {
                    MoveLegalResponse {
                        made_move: Some(undo),
                        is_legal: !in_check
                    }
                }
            }
            Move::Pass => {
                // Null Moves are not legal in chess.
                // They wouldn't be generated anyways, but I think it would be best to show them as illegal here anyways.
                // Consumers of the library can still make null moves, it just won't be generated by the movegen.
                MoveLegalResponse {
                    made_move: None,
                    is_legal: false
                }
            }
        }
    }

    fn use_pseudolegal(&self) -> bool {
        return true;
    }

    fn encode_action(&self, board: &Board<T>, action: &Move) -> Vec<String> {
        match action {
            Move::Action(action) => {
                match action.from {
                    Some(from) => {
                        let mut moves = vec![
                            format!(
                                "{}{}{}",
                                board.encode_position(from),
                                board.encode_position(action.to),
                                board.game.pieces[action.piece_type as usize].format_info(board, action.info)
                            )
                        ];

                        if action.piece_type == KING as u16 && action.move_type == CASTLING_MOVE {
                            let direction = ((from as i32) - (action.to as i32)).signum();
                            let new_pos = ((from as i32) + (direction * 2)) as u16;

                            moves.push(format!(
                                "{}{}{}",
                                board.encode_position(from),
                                board.encode_position(new_pos),
                                board.game.pieces[action.piece_type as usize].format_info(board, action.info)
                            ))
                        }

                        moves
                    },
                    None => vec![ "----".to_string() ]
                }
            },
            Move::Pass => vec! [ "0000".to_string() ]
        }   
    }

    fn update(&self, action: &Move, state: &BoardState<T>) -> TurnUpdate {
        TurnUpdate {
            turns: CounterUpdate::Next,
            sub_moves: match action {
                Move::Action(action) => {
                    let is_pawn_move = action.piece_type == 0;
                    let is_capture = (BitBoard::<T>::from_lsb(action.to) & state.all_pieces).is_set() && !(action.piece_type == 5 && action.move_type == 1);

                    if is_pawn_move || is_capture {
                        CounterUpdate::To(0)
                    } else {
                        CounterUpdate::Next
                    }
                },
                Move::Pass => CounterUpdate::Next
            },
            full_moves: CounterUpdate::Next
        }
    }

    fn get_theoretical_moves(&self, board: &Board<T>) -> Vec<TheoreticalMove> {
        get_theoretical_moves_bound(board, 4, false)
    }

    fn get_max_available_moves(&self) -> u32 {
        220
    }
}
