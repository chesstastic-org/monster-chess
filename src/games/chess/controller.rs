use crate::{board::{game::MoveController, Board, actions::Action}, bitboard::BitBoard};

use super::ATTACKS_MODE;

#[derive(Debug)]
pub struct ChessMoveController<const T: usize>;

impl<const T: usize> MoveController<T> for ChessMoveController<T> {
    fn transform_moves(&self, board: &mut Board<T>, mode: u32, actions: Vec<Option<Action>>) -> Vec<Option<Action>> {
        let moves = board.generate_moves(mode);
        let mut legal_moves = Vec::with_capacity(moves.len());
        for action in moves {
            if self.is_legal(board, &action) {
                legal_moves.push(action);
            }
        }
        legal_moves
    }

    fn is_legal(&self, board: &mut Board<T>, action: &Option<Action>) -> bool {
        match action {
            Some(action) => {
                let to_board = BitBoard::from_lsb(action.to);
                let kings = board.state.pieces[5];
                if (to_board & kings).is_set() {
                    return false;
                }

                let current_team = board.state.moving_team;

                board.make_move(&Some(*action));
                let kings = board.state.pieces[5];
                let king_board = board.state.teams[current_team as usize] & kings;
                let in_check = board.can_move(board.state.moving_team, king_board, ATTACKS_MODE);
                board.undo_move();
                !in_check
            }
            None => {
                // Null Moves are not legal in chess.
                // They wouldn't be generated anyways, but I think it would be best to show them as illegal here anyways.
                // Consumers of the library can still make null moves, it just won't be generated by the movegen.
                false
            }
        }
    }

    fn use_psuedolegal(&self) -> bool {
        return true;
    }

    fn encode_action(&self, board: &Board<T>, action: &Option<Action>) -> Vec<String> {
        vec![
            match action {
                Some(action) => {
                    match action.from {
                        Some(from) => format!(
                            "{}{}{}",
                            board.encode_position(from),
                            board.encode_position(action.to),
                            board.game.pieces[action.piece_type].format_info(board, action.info)
                        ),
                        None => "----".to_string()
                    }
                },
                None => "0000".to_string()
            }   
        ]
    }
}
