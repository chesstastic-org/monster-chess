use crate::{board::{game::{MoveController, get_theoretical_moves_bound}, Board, actions::{Action, TheoreticalAction, Move, TheoreticalMove, CounterUpdate, TurnUpdate}, BoardState}, bitboard::BitBoard};

use super::{ATTACKS_MODE, pieces::CASTLING_MOVE};

#[derive(Debug)]
pub struct ChessMoveController<const T: usize>;

impl<const T: usize> MoveController<T> for ChessMoveController<T> {
    fn transform_moves(&self, board: &mut Board<T>, mode: u16, actions: Vec<Move>) -> Vec<Move> {
        let moves = board.generate_moves(mode);
        let mut legal_moves = Vec::with_capacity(moves.len());
        for action in moves {
            if self.is_legal(board, &action) {
                legal_moves.push(action);
            }
        }
        legal_moves
    }

    fn is_legal(&self, board: &mut Board<T>, action: &Move) -> bool {
        match action {
            Move::Action(action) => {
                let to_board = BitBoard::from_lsb(action.to);
                let kings = board.state.pieces[5];
                if (to_board & kings).is_set() {
                    return false;
                }

                let current_team = board.state.moving_team;

                let undo = board.make_move(&Move::Action(*action));
                let kings = board.state.pieces[5];
                let king_board = board.state.teams[current_team as usize] & kings;
                let in_check = board.can_move(board.state.moving_team, king_board, ATTACKS_MODE);
                board.undo_move(undo);
                !in_check
            }
            Move::Pass => {
                // Null Moves are not legal in chess.
                // They wouldn't be generated anyways, but I think it would be best to show them as illegal here anyways.
                // Consumers of the library can still make null moves, it just won't be generated by the movegen.
                false
            }
        }
    }

    fn use_pseudolegal(&self) -> bool {
        return true;
    }

    fn encode_action(&self, board: &Board<T>, action: &Move) -> Vec<String> {
        let mut moves = vec![
            match action {
                Move::Action(action) => {
                    match action.from {
                        Some(from) => {
                            format!(
                                "{}{}{}",
                                board.encode_position(from),
                                board.encode_position(action.to),
                                board.game.pieces[action.piece_type as usize].format_info(board, action.info)
                            )
                        },
                        None => "----".to_string()
                    }
                },
                Move::Pass => "0000".to_string()
            }   
        ];

        if let Move::Action(action) = action {
            if action.piece_type == 5 && action.move_type == CASTLING_MOVE {
                if let Some(from) = action.from {
                    let dir = (action.to as i16) - (from as i16).signum();
                    let to = ((from as i16) + (2 * dir)) as u16;
                    moves.push(format!(
                        "{}{}{}",
                        board.encode_position(from),
                        board.encode_position(to),
                        board.game.pieces[action.piece_type as usize].format_info(board, action.info)
                    ))
                }
            }
        }

        moves
    }

    fn update(&self, action: &Move, state: &BoardState<T>) -> TurnUpdate {
        TurnUpdate {
            turns: CounterUpdate::Next,
            sub_moves: match action {
                Move::Action(action) => {
                    let is_pawn_move = action.piece_type == 0;
                    let is_capture = (BitBoard::<T>::from_lsb(action.to) & state.all_pieces).is_set() && !(action.piece_type == 5 && action.move_type == 1);

                    if is_pawn_move || is_capture {
                        CounterUpdate::To(0)
                    } else {
                        CounterUpdate::Next
                    }
                },
                Move::Pass => CounterUpdate::Next
            },
            full_moves: CounterUpdate::Next
        }
    }

    fn get_theoretical_moves(&self, board: &Board<T>) -> Vec<TheoreticalMove> {
        get_theoretical_moves_bound(board, 4, false)
    }

    fn get_max_available_moves(&self) -> u32 {
        220
    }
}
